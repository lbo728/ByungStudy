# 블록체인이 데이터를 보호하는 방법 (p176 ~ p187)

조작할 때 드는 비용을 높여 포기하게 만들기

> **비유: 귀족 가문 족보 위조**  
> 누군가 귀족 가문의 자손인 척 위장하려는 상황을 가정해 보자. 어떻게 하면 그렇게 보일 수 있을까? 족보를 위조하면 가능하다. 예컨대 가상의 귀족 할아버지를 만들어내 위조된 가계도 상에서 적당히 관계를 설정하는 것이다. 하지만 이 정도 조작은 손쉽게 들통날 것이다. 가계도는 가족 관계를 통해 다른 집안의 가계도와 얽히기 때문이다. 따라서 꾸며낸 가문이 잘 먹히게 하려면 **저명한 귀족 가문들 중 한 곳의 가계 문서를 위조해서 그 가문의 역사에 가공의 할아버지가 등장하도록** 슬쩍 끼워넣을 필요가 있다.
>
> 그러나 이 정도로는 충분치 않으며, 가공의 할아버지의 삶이 진짜처럼 보이게 하려면 그의 학력, 경력은 물론 유년시절을 포함한 생애 전체를 꾸며내야 한다. 그러자면 출생증명서, 학교 등록 서류, 졸업장, 학위증명서, 직업증명서, 멤버십 등 관련 서류도 모두 위조해야 한다. 이 모든 문서를 조작하는 것은 무척 복잡하고 엄청난 비용이 소모되므로, 보통은 포기할 것이다.
>
> 이 사례는, **과거를 위조할 수는 있지만 극단적으로 비용이 많이 소모된다는 사실**을 보여준다. 이 예를 토대로, 블록체인이 트랜잭션 이력의 위조를 방지 하는 방법을 설명할 수 있다.

<br>

## 1. 목표

블록체인이 유지하는 전체 트랜잭션 이력을 불변성 데이터로 만들어 위조나 조작이 없도록 하는 것이다.

<br>

## 2. 해결해야 할 과제

순수 분산 P2P 시스템을 개방한 채, 조작이나 위조의 위험으로부터 트랜잭션 데이터를 보호하는 것

<br>

## 3. 아이디어

"트랜잭션 이력을 부정직한 노드의 조작 위험으로부터 보호하려면, **처음부터 아무도 이력을 조작하지 못하게** 막아놓는다."

<br>

## 4. 불변성은 읽기 전용의 다른 이름

`불변성`(immutability) 데이터 == `읽기 전용`(read-only) 데이터

- 한번 생성되면 절대로 변경될 수 없는 불변성의 특성과, 읽거나 볼 수만 있다는 읽기 전용의 특징은 서로 유사
- **불변성**: 바꿀 수 없는 무언가

<br>

## 5. 작동 원리: 큰 그림 살펴보기

### 1 | 조작이 쉽게 눈에 띄도록 함

변경-감지 방식으로 저장하는 블록체인-데이터-구조에서 데이터 일부를 **아무도 눈치채지 못하게 조용히 조작하는 것은 불가능**

- 아무리 사소한 변경이라도 그 가리키는 해시 참조를 손상시켜 무효화 해야 뚜렷이 발견되기 때문

<br>

### 2 | 변경을 끼워넣으려면 재작성하도록 의무화

블록체인-데이터-구조는 내용 변경에 있어서 `모-아니면-도` 접근방식을 추구

- 변경된 부분부터 헤드까지 전체 체인을 완전히 변경하거나 아예 처음부터 변경할 생각 말고 내버려둬야 함

<br>

### 3 | 데이터 추가에 엄청난 계산량이 필요하도록 함

블록체인-기술-모음은 블록체인-데이터-구조의 모든 블록에 대해 작성, 재작성, 추가 작업에 엄청난 계산 비용이 필요하게끔 만듬

- 계산 비용은 해시 퍼즐로 인해 발생
  - 조작 하기 위해서는, 조작할 지점부터 체인의 헤드에 이르는 **모든 해시 퍼즐을 풀어 전체 데이터 구조를 변경하는 비용**을 감수해야함

<br>

## 6. 작동 원리: 세부 사항 살펴보기

블록체인-데이터-구조를 불변성으로 만들기 위해서는 **새 블록을 추가하는 것이 계산적으로 비싼 과제가 되도록** 만들어야 함. 이 목적을 위해 고려해야할 사항들,

### 1 | 필수 데이터

- 트랜잭션 데이터를 담고 있는 `머클 트리의 루트`
- 이전 블록 헤더를 가리키는 `해시 참조`
- 해시 퍼즐의 `난이도`
- 해시 퍼즐 풀이를 시작한 `시각`
- 해시 퍼즐을 해결할 수 있는 `난스`

<br>

### 2 | 새 블록을 생성하는 프로세스

1. 새로 추가되는 트랜잭션을 담고 있는 머클 트리의 루트 얻기
2. 새 블록 헤더의 입장에서 이전 블록 헤더를 가리키는 해시 참조 생성하기
3. 필요 난이도 획득하기
4. 현재 시각 읽기
5. 1 ~ 4번에 언급된 데이터를 포함하는 예비 블록 헤더 생성하기
6. 예비 블록 헤더에 해당하는 해시 퍼즐 해결하기
7. 해시 퍼즐을 해결할 난스를 예비 헤더에 포함시켜 새 블록 완결하기

- `난이도`가 블록 헤더의 일부이고, 따라서 블록 `해시값`의 일부라는 점을 주목
  - 이 부분이 난이도를 임의로 줄여, 해시 퍼즐 해결에 필요한 **계산 비용 회피를 막아주는** 장치

![블록체인_무엇인가-해시_퍼즐_도식](https://github.com/lbo728/BlockChainStudy/assets/72309817/5afc9db7-c914-492d-978f-4c39b9872622)
<해시 퍼즐 도식>

<br>
 
 ### 3 | 검증 규칙
 1. **직전 블록을 가리키는** 유효한 해시 참조를 가지고 있어야 한다.
 2. **트랜잭션 데이터를 갖고 있는** 머클 트리의 루트를 포함해야 한다.
 3. **정확한 난이도**를 가지고 있어야 한다.
 4. 타임 스탬프는 **직전 블록 헤더의 타임 스탬프 이후**여야 한다.
    - 블록과 트랜잭션 데이터들이 추가된 순서에 따라 정렬되어 있음을 보장해야함
 5. **난스를 포함**해야 한다.
 6. **위 5개의 데이터 조각을 합친** 해시값으로 난이도를 충족해야 한다.

> 해시 퍼즐을 해결하여 블록체인-데이터-구조에 새 블록을 추가하는 행위를 `마이닝`(mining) 혹은 `블록 마이닝`이라 부른다.

<br>

## 7. 작동하는 이유

블록체인-데이터-구조는 사소한 변경이라도 확연히 드러나는데, 이는 해시 참조가 가리키는 데이터에 변경이 있으면 즉시 **그 해시 참조 자체를 손상시키는 성질로부터** 비롯됨

- 데이터 조작이 있을 경우 영향받은 모든 블록을 다시 작성하도록 만듬
  - 달리 표현하면, 조작된 데이터를 끼워넣기 위해 재작성해야 하는 누적 계산량이 어마어마함
- 결과적으로, 블록체인-데이터-구조는 `추가 전용 불변성 데이터 저장소`가 됨

<br>

## 8. 높은 계산 비용이 조작 위험을 막아준다

현재 헤드로부터 20블록 떨어진 머클 트리의 트랜잭션 데이터를 조작하기 위해 수행되어야 할 작업들.

1. 조작된 트랜잭션 데이터가 속한 머클 트리 다시 작성
2. 재작성된 머클 트리의 루트가 속한 블록 헤더 다시 작성
3. 블록체인-데이터-구조의 헤드까지 이어진 모든 후속 블록 헤더 재작성

→ 2번에서 20개의 퍼즐을 해결하기 위해 통상 10분 소요된다면, 20개의 블록 헤더 트랜잭션 조작을 위해 210분이 필요함
→ 블록체인-데이터-구조를 변경하려는 **노드가 포기하게 만드는 요인**

> **옮긴이주**  
>  사실 비트코인에 국한된 작업 증명 방식이고, 다른 암호화폐에서는 개선한 다양한 방식을 사용하고 있음

<br>

## 9. 결국, 불변성은 해시 퍼즐의 난이도에 달려 있다

블록체인-데이터-구조의 불변성은 해시 퍼즐의 난이도에 달려있음

- 제 응용에서는 새 블록이 추가되는 속도가 빨리지면 난이도를 높이고, 그 반대면 난이도를 낮추는 방식을 적용
  - 기술의 발달에 따라 컴퓨터의 계산 능력이 나날이 바뀌고 있기 때문

> **옮긴이주**  
>  비트코인은 2,016개의 블록이 생성될 때마다 2주(1,209,600초)가 지났는지 확인한다. 2주가 안 지났으면 비율에 따라 난이도를 최대 300%까지 올리고, 2주가 지났으면 난이도를 최대 75% 수준까지 낮춘다. 2주 동안 2,016개 블록이 생성된다는 의미는 매 10분(600초)마다 하나의 블록이 생성되는 게 적절하다고 본다는 뜻이다.
