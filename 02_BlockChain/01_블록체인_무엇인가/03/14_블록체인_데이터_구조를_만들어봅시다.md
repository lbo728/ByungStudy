# 블록체인-데이터-구조를 만들어봅시다 (p151 ~ p165 )

전체 트랜잭션 데이터 구축 및 유지하기

<br>

> **비유: 도서관의 도서일람표**  
> 도서일람표에는 도서관에 있는 모든 책이 등록되어 있다. 일람표의 각 카드는 책 하나를 나타내고, 카드에는 저자 이름, 책 제목, 출판일, 도서관 내 책 위치(층, 방, 책꽃이, 선반 번호 등) 등의 중요 정보가 담겨 있다. 대부분의 도서관에는 몇 가지 분류 양식이 있다. 예를 들어 저자 일람표는 저자 이름ㅇ르 알파벳 순서로 정렬해서 구성하고, 제목 일람표는 제목의 알파벳 순으로 카드가 정렬된다. 또한 도서관이 해당 책을 구비한 시점을 기준으로 정렬하여 일람표를 만들 수도 있다.

<br>

## 1. 목표

전체 트랜잭션 이력을 **정렬 상태**로 유지하기

<br>

## 2. 해결해야 할 과제

모든 트랜잭션 데이터를, 발생 순서를 유지하면서 어떠한 변경이 있을 경우 재빠르게 감지할 수 있도록 저장하는 것이 과제

- 트랜잭션 이력을 조작하거나 위조하는 것을 방지하기 위한 근간

<br>

## 3. 아이디어

"트랜잭션 데이터의 도서관 만들기"

- 도서관의 일람표는 트랜잭션이 추가된 순서대로 정렬
- 데이터는 `해시 참조`를 사용해 `변경-감지 방식`으로 저장되어야 함

<br>

## 4. 책을 블록체인-데이터-구조로 변환하기

책의 형식에 변화를 주어 '순서일람표를 가진 작은 도서관'으로 만들기

### 시작점: 책

- **내용 보관**: 책은 각각의 페이지에 내용을 보관한다.
- **정렬**: 책의 모든 페이지들은 물론 각 페이지 내의 문장도 모두 정렬 순서를 지킨다.
- **페이지 연결**: 책은 물리적으로는 책 자체에 연결되어 있고, 논리적으로는 내용과 페이지 번호로 연결되어 있다.

→ 이런 성질로 인해, 책은 **페이지를 앞뒤로 넘기거나** 페이지 번호를 활용해 **특정 페이지를 찾아가는** 방법으로 `검색`이 가능
→ 이 성질 일부를 변경하기

<br>

### 변환 1: 페이지 의존성을 분명히 드러내기

![책_페이지_도식화](https://github.com/lbo728/BlockChainStudy/assets/72309817/569e9153-159d-40cb-b767-bb43ea3f87d8)
<책 페이지의 도식화>

<br>

- **페이지 번호**: 연속성 검증을 통해 누락 여부 확인 가능

  - 페이지 번호는 `자연수`를 연속적으로 매기는 것이 전제 되어있기 때문

- 각 페이지에 현재 페이지 번호는 물론, 직전 페이지 번호까지 표시 되어 있음
  - 즉, 현재 페이지와 직전 페이지 사이에 종속관계를 형성

![직전_페이지_명시한_책](https://github.com/lbo728/BlockChainStudy/assets/72309817/c3eba7be-9e1a-4f0e-ac2b-86980194566f)
<직전 페이지를 명시한 책 페이지>

<br>

### 변환 2: 내용과 페이지 번호 분리하기

책에서 `내용`을 아웃소싱하면, 책은 오로지 **순서를 유지하는 일**에만 집중할 수 있다.

하단의 이미지에서,

- 페이지에 내용은 더 이상 없고 대신 내용이 있는 곳의 `참조값`만 있음
  - 실제 내용은 어디에든 저장할 수 있음

→ 즉, 책은 **작은 도서관**이 되었음

- 기존에 `내용`과 `페이지 번호`를 같이 저장하고 있던 책은,
  - 일람표로 바뀌어 단지 **내용의 순서를 유지하는 역할**이 됨
  - `내용`은 `고유 참조값`으로 식별되는 별도 페이지에 저장

![아웃소싱된_내용](https://github.com/lbo728/BlockChainStudy/assets/72309817/7ca79bff-90f4-4043-85e9-af875670379a)
<아웃소싱된 내용을 가리키는 참조값을 가진 책 페이지>

<br>

### 변환 3: 페이지 번호를 참조값으로 대체하기

페이지 번호를 매기는 `자연수`를 `참조값`으로 대체한다.

- 이전에 페이지 번호 42였던 페이지는 페이지 참조값 8118E736으로 식별됨
- 바로 앞 페이지 번호 참조값도 같이 변경됨

![페이지_번호로_참조값](https://github.com/lbo728/BlockChainStudy/assets/72309817/c85d83f6-2a28-4958-810b-b8e470f3949d)
<페이지 번호로 참조값을 사용한 책의 페이지>

<br>

### 변환 4: 참조값 생성하기

고유한 참조값을 생성하는 가장 좋은 방법은, `암호화 해시값`을 사용하는 것

- 이 방법을 이용해, 페이지 번호와 함께 내용 페이지도 식별할 수 있음
- 책의 페이지 참조값은, 페이지의 내용(**내용 참조값 + 앞 페이지 참조값**)에 기반해 계산
  - 예시: 페이지 참조값 B779E800 = 011C01C1 185F7Db3의 해시값

<br>

### 변화 5: 책등 없애기

여기서 책등을 없애버려도, 페이지의 순서를 잃지 않음

- 각 페이지가 `앞 페이지의 참조값`을 가지고 있기 때문
- 순서일람표의 **마지막 페이지만 따로 보관하고 있으면** 언제든지 페이지를 역순으로 검색할 수 있음

<br>

### 목표 달성: 결과 평가

- 전통적인 책을 '정렬되지 않은 두 개의 페이지 더미'로 분리
- 두 페이지 더미를 고유한 참조값으로 서로 연결시킴
  - 내용
  - 순서(편의상 `순서일람표`라 표현)
    - 직전 페이지의` 참조값`
    - 해당 내용 페이지의 `참조값`

→ `정보 저장`으로부터 `순서`를 분리해냈고, 페이지의 `물리적 위치`로부터 `논리적 위치`(순서)를 분리함

<br>

| 성질        | 변환 전 책                     | 변환 후 책                                                     |
| ----------- | ------------------------------ | -------------------------------------------------------------- |
| 내용 저장   | 페이지 자체                    | 별도의 내용 페이지                                             |
|             |                                | 각 내용 페이지는 고유의 참조값에 의해 식별됨                   |
| 내용 정렬   | 물리적: 책 내의 페이지 위치    | 논리적: 내용 페이지를 가리키는 참조값을 가진 순서일람표를 통해 |
|             | 논리적: 페이지 번호            |                                                                |
| 페이지 연결 | 물리적: 페이지를 책등에 붙여서 | 논리적: 참조값을 통해                                          |
|             | 논리적: 페이지 번호를 통해     |                                                                |
| 페이지 검색 | 전방                           | 후방만 가능: 직전 페이지를 가리키는 참조값을 따라감            |
|             | 후방                           |                                                                |
|             | 페이지 번호로 직접 가기        |                                                                |

<br>

### 변환된 책으로 블록체인-데이터-구조 이해하기

변환된 책은 `블록체인-데이터-구조`를 나타냄

변환된 책의 5가지 요소,

1. 순서일람표 페이지와 해당 내용 페이지로 구성된 가상 단위
2. 순서일람표라 불리는 페이지 더미
3. 내용을 담고 있는 페이지 더미
4. 순서일람표 페이지를 식별하고 연결할 페이지 참족밧
5. 내용 페이지를 식별하고 연결할 내용 참조값

<br>

| **변환된 책**                                             | **블록체인-데이터-구조**                |
| --------------------------------------------------------- | --------------------------------------- |
| 순서일람표의 페이지                                       | 블록 헤더                               |
| 전체 순서일람표                                           | 블록 헤더의 체인                        |
| 순서일람표의 페이지 참조값                                | 블록 헤더의 암호화 해시값               |
| 직전 페이지를 가리키는 참조값                             | 직전 블록 헤더의 암호화 해시값          |
| 내용                                                      | 트랜잭션 데이터                         |
| 내용 페이지                                               | 트랜잭션 데이터를 가진 머클 트리        |
| 내용 페이지를 가리키는 참조값                             | 트랜잭션 데이터를 가진 머클 트리의 루트 |
| 순서일람표 페이지와 해당 내용 페이지로 구성된 가상의 단위 | 블록체인-데이터-구조의 한 블록          |
| 전체 순서일람표와 전체 내용 페이지                        | 블록체인-데이터-구조                    |

<br>

#### 1 | 순서일람표 페이지와 해당 내용 페이지로 구성된 가상 단위

순서일람표 `페이지`는, `해시 참조`를 통해 내용 페이지를 참조함으로써 가상의 한 단위를 형성하게 됨

- 이것을 `블록`이라 부르고, 블록들이 모두 모여 `블록체인-데이터-구조`를 형성

<br>

#### 2 | 순서일람표라 불리는 페이지 더미

순서일람표의 각 `페이지`는, 블록체인-데이터-구조 내 단일 `블록 헤더`와 동일

- 블로 헤더는 참조를 통해 선형으로 연결되어, 블록 헤더의 `체인`을 형성
- 블록 헤더의 체인은 트랜잭션 데이터를 직접 저장하지 않고, 해당 트랜잭션 데이터에 대한 `해시 참조`만 저장한다.

<br>

#### 3 | 내용을 담고 있는 페이지 더미

변환된 책의 `내용`은, 블록체인에 의해 유지되는 **트랜잭션 데이터**와 같음

- 실제 블록체인 응용에서는 **내용 페이지가 없음**(독자의 이햬를 돕기 위한 개념)
- 실제 블록체인 응용은, 데이터(e.g.트랜잭션 데이터)를 `머클 트리`라 불리는 데이터베이스에 직접 저장하고, 머클 트리의 `루트`는 블록 헤더에 저장됨

<br>

#### 4 | 순서일람표 페이지를 식별하고 연결할 페이지 참조값

변환된 책에서의 `페이지 참조값`은 , 블록체인-데이터-구조 내 **개별 블록 헤더의** `암호화 해시값`과 같음

- 각각 `블록 해시` 또는 `이전 블록의 해시`라 불림
- 이 값은 각 블록 헤더를 **고유하게 식별**하고, **이전 블록 헤더를 참조**하기 위해 사용됨

<br>

#### 5 | 내용 페이지를 식별하고 연결할 내용 참조값

변환된 책에서의 `내용 참조값`은 **연계된 트랜잭션 데이터를 가리키는 블록 헤더의** `해시 참조`와 같음

- 블록 헤더에 저장된 내용 `참조값`은, 데이터베이스에 저장된 트랜잭션 데이터의 머클 트리의 `루트`임
- 이로 인해 순서 일람표(`블록 헤더`)와 상응하는 내용(트랜잭션의 `머클 트리`)의 **가상 단위**가 형성됨

<br>

<details>
<summary style="background-color: rgba(82, 46, 42, 1); color: #EE5858;">블록 헤더란</summary>

<div markdown="1">
<b>블록 헤더(Block Header)</b>는 블록을 구성하는 요소를 구분한 단위 중 하나이다. 각각의 블록은 머리와 몸이라고 할 수 있는 <b>블록 헤더</b>와 <b>블록 바디</b>로 구성되어 있다. 블록 헤더와 블록 바디는 서로의 정보를 비교하면서 위변조 가능성을 확인하며 무결성을 높인다.

<br/>

- **비트코인** 블록 헤더의 구성요소

  - 현재 블록과 이전 블록의 해시값
  - 해당 블록을 만든 비트코인의 버전
  - 머클루트
  - 타임스탬프
  - 현재 채굴 난이도
  - 논스
    <br/>

- **이더리움** 블록 헤더의 구성요소
  - 부모해시(parentHash) : 부모 블록의 해시값
  - 엉클해시(uncleHash) : 현재 블록의 엉클 블록들의 해시값
  - 주소(beneficiary) : 채굴 후 해당 트랜잭션의 수수료를 받을 계정 주소
  - 상태루트(stateRoot) : 계정의 상태정보가 모여있는 머클 패트리시아 트리의 루트 노드 해시값
  - 트랜잭션루트(transactionsRoot) : 블록의 모든 트랜잭션에 대한 머클트리의 루트노드 해시값
  - 영수증루트(receiptsRoot) : 해당 블록 내 모든 트랜잭션에 대한 일종의 영수증 머클트리의 루트노드 해시값
  - 로그블룸(logsBloom) : 로그 정보를 사용하는데 필요한 32바이트 블룸필터
  - 난이도(difficulity) : 블록 생성 난이도
  - 블록번호(number) : 해당 블록 번호
  - 가스한도(gasLimit) : 블록 당 지급 가능한 최대 가스의 제한량
  - 사용된 가스(gasUsed) : 해당 블록 내 트랜잭션에 사용된 가스의 총합
  - 타임테이블(time : 해당 블록의 최초 생성시간
  - 믹스해시, 논스(mixHash, nonce : 해당 블록이 충분한 연산을 했음을 입증하는 해시값
  - 기타(extra) : 블록의 기타 정보

※ 블록체인 네트워크마다 헤더에 저장되어 있는 내용은 다를 수 있다.

**_참고: [블록헤더 | 해시넷](http://wiki.hash.kr/index.php/%EB%B8%94%EB%A1%9D%ED%97%A4%EB%8D%94)_**

</div>
</details>

<br>

## 5. 블록체인-데이터-구조에서 트랜잭션 저장하는 방법

- 블록 1과 블록 2는 **가상 구조인 블록의 본질**을 강조하기 위해 점선으로 표시
- 각 블록은 블록 헤더 1과 블록 헤더2라는 `블록 헤더`를 각각 가짐
- 블록 1은 `최초 블록`이기 때문에 이전 블록이 없으므로, 어떠한 참조도 없음
- 블록 2는 `이전 블록`(블록1)이 있으므로, 블록 헤더 2에 `참조 B1`이 있음
- 그림의 블록체인-데이터-구조는 각기 다른 두 개의 `머클 트리`를 가리키는 `해시 참조`를 가짐
- 두 머클 트리의 `루트`는 각각 **R12**와 **R34**
- 머클 트리 루트의 이름으로 각각 가지고 있는 트랜잭션 데이터를 짐작할 수 있음
  - 예를 들어, **루트가 R12인 머클 트리**는 처음 두 트랜잭션인 **트랜잭션 1**과 **트랜잭션 2** 및 이들을 가리키는 해당 `해시 참조` **R1**과 **R2**를 가지고 있음

![4개_트랜잭션](https://github.com/lbo728/BlockChainStudy/assets/72309817/861b0304-1e11-4606-b39f-2ec2f625e402)
<4개의 트랜잭션을 가지는 단순화된 블록체인-데이터-구조>

<br>

#### 이 그림과 같은 블록체인을 유지하고 있는 분산 P2P 시스템의 경우

이 시스템에 참여하면 `전체 트랜잭션 데이터`, `모든 해시 참조값`, `모든 블록 헤더`를 수신하게 됨

- 로컬 컴퓨터는, 데이터를 모두 저장하고 저장된 데이터들을 가리키는 `해시 참조`를 가진 `블록체인-데이터-구조`를 생성함
- 이렇게 데이터와 **가장 최근의 블록 헤더에 대한 참조**만 가지고 있으면, 최초 생성 이래 시스템에 제출된 모든 트랜잭션 데이터의 이력을 **역순으로 검색**할 수 있다.

<br>

가장 최근에 추가된 `블록 헤더`는, 블록체인-데이터-구조의 `헤드`라고 부른다는 것을 주목해야 한다.
→ 블록체인-데이터-구조에는 각자의 헤더를 가진 수많은 블록이 존재하지만, 전체 블록체인-데이터-구조는 **오직 하나의** `헤드`만 가진다

- 위 그림에서 **참조 B2**가 블록체인-데이터-구조의 `헤드`

<br>

> **핵심 정리**
>
> - 블록체인-데이터-구조는 `해시 참조`를 광범위하게 사용하기 때문에 `변화-감지 저장소`의 성질을 가짐
> - 블록체인-데이터-구조는 `블록`이라 불리는, **순서대로 정렬된 단위로 구성된** 특수 데이터 구조
> - 블록체인-데이터-구조의 각 블록은 `블록 헤더`와 `트랜잭션 데이터`를 가지고 있는 `머클 트리`로 이루어짐
> - 블록체인-데이터-구조는 두 개의 데이터 구조로 구성됨
>   - `블록 헤더의 정렬된 체인`
>   - `머클 트리`
> - **블록 헤더의 정렬된 체인**은 도서관의 `도서일람표`를 디지털로 구현한 것으로 볼 수 있음
>   - 개별 일람카드는 일람표의 정렬 규칙에 따라 순서대로 정렬되어 일람표에 하나씩 추가됨
> - 각 블록 헤더가 `이전 블록 헤더`를 참조하면 **개별 블록 헤더와 블록의 순서를 각각 유지할** 수 있고, 이것이 모여서 블록체인-데이터-구조를 형성함
> - 블록체인-데이터-구조의 각 블록 헤더는
>   - `암호화 해시값`으로 식별할 수 있음
>   - 이전 블록 헤더를 가리키는 해시 참조, 응용과제에 특화된 데이터를 가리키는 `해시 참조`를 가지고 있음
> - 응용과제에 특화된 데이터를 가리키는 해시 참조는, 일반적으로 응용과제에 특화된 데이터를 가리키는 해시 참조를 유지하는 `머클 트리의 루트`임
