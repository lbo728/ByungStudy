# 데이터 해싱하기 (p98 ~ p109)

지문처럼 만들어 데이터 식별하기

<br>

- `해시값`(hash value)는 지문의 디지털 버전

## 1. 목표: 암호화 해싱으로 데이터 식별하기

분산 P2P 시스템에서는 엄청난 양의 트랜잭션 데이터를 다루기 때문에, **디지털 지문(해시값)을 사용해 트랜잭션을 식별**해 내고, 나아가 모든 종류의 데이터를 식별할 수 있게 하는 것이 목표

<br>

## 2. 작동 원리

`해시 함수`(Hash function): 어떤 형태의 데이터든 입력 데이터의 길이와 상관없이 고정된 길이의 숫자로 변환하는 함수

- 한 번에 하나의 데이터만 입력받아 그 데이터를 구성하는 비트와 바이트를 이용해서 해시값을 생성
- 해시값은 함수의 종류에 따라 서로 다른 길이로 생성
  - 요구되는 길이를 충족하기 위해 앞자리 수를 모두 0으로 채우기도 함

`암호화 해시 함수`(Cryptographic hash function)라 불리는 중요한 해시 함수 그룹은, **어떤 데이터라도 고유의 디지털 지문을 생성**해 주는 해시 함수

암호화 해시 함수의 특징은,

### 1) 어떤 종류의 데이터든 즉시 해시값 제공

2가지 성질의 조합

1. 해시 함수는 어떤 종류의 데이터든 해시값을 생성할 수 있음
2. 해시 함수는 해시값 계산을 빠르게 할 수 있음

→ 이 2가지 성질은 대단히 중요한데, 해시 함수가 오류 메시지 같은 쓸모없는 것을 생성하거나 결과를 반환하기 위해 긴 시간을 소비해서는 안되기 때문

<br>

### 2) 확정적

`확정적`(deterministic)이란 동일하게 일벽했을 때, 동일하게 출력해야 한다는 의미

- 해시 값이 다르다면, 오로지 입력 값이 달라서 생긴 결과일 뿐, 해시 함수 내부 작동에 의한 것일 수는 없음

### 3) 의사 난수

`의사 난수`(peudorandom)란, 입력 데이터가 변하면 해시값이 **예측 불**가하게 변해야 한다는 의미

- 즉, 적은 비트만 바꿔서 입력하더라도 해시값은 크게 변해 항상 예측 불가능해야 한다는 뜻

<br>

### 4) 일방 함수

`일방 함수`(one-way function)는 출력으로 입력을 알 수 있는 방법이 존재하지 않는 함수를 의미

- 역으로 이용할 수 없다는 뜻
  → 해시값을 이용해 원래 입력 값는 복원하는 것이 불가능하다는 의미
  - 마치 지문만으로는 그 사람에 대한 어떤 정보도 얻을 수 없는 것
- 일방 함수는 `비가역 함수`라고도 함

<br>

### 5) 충돌 회피

`충돌 회피`(collision resistant)는 둘 이상읟 데이터가 동일한 해시값을 생성하는 것이 지극히 어려울 때, 그 해시 함수를 의미

- 쉽게 말해, **서로 다른 데이터가 동일한 해시값을 가질 확률이 매우 낮은 해시 함수**
- 이러한 해시값은 고유성을 지녀 데이터 식별에 사용할 수 있음
  - 반대로, **해시 충돌**이 일어난다면, 그 해시값은 동일한 지문을 가진 사람이 둘 이상 존재하는 것과 같음

<br>

## 3. 해시 함수 직접 적용해보기

#### 짧은 텍스트의 해시값 계산

[🔗 예제 링크](http://www.blockchain-basics.com/HashFunctions.html)

<img width="1076" alt="hashfunction" src="https://github.com/lbo728/BlockChainStudy/assets/72309817/501b85a2-c295-4ff5-acf8-f307a8943c16">

`해시값`은 종종 `해시 수`로도 불리며, 0부터 9까지의 수와 함께 10부터 15까지의 수를 나타내기 위해 A부터 F까지의 문자도 이용한다.(16진수)

- 암호화 해시값은 상당히 길어서 사람 눈으로 읽고 비교하기 어려움

<br>

#### 짧은 텍스트의 축약 해시값 계산

`SHA256` 암호화 해시값의 축약된 버전

[🔗 예제 링크](http://www.blockchain-basics.com/Hashing.html)

<img width="1076" alt="hashing" src="https://github.com/lbo728/BlockChainStudy/assets/72309817/01a8727d-0da5-40bd-bad2-459494690cb8">

<br>

## 4. 해싱된 데이터의 5가지 패턴

서로 독립적인 데이터들의 묶음에 대해 하나의 해시값만 생성하고 싶을 때, 사용할 수 있는 다섯 가지 패턴

### 1) 독립 해싱

`독립 해싱`(Independent hashing)은 각 데이터에 대해 독립적으로 해시 함수를 적용하는 방법

<br>

![독립해싱](https://github.com/lbo728/BlockChainStudy/assets/72309817/d92dda7c-f9f5-46a7-b265-315f6664b6e8)

<br>

### 2) 반복 해싱

`반복 해싱`(Repeated hashing)은 해시 출력값에 해시 함수를 한번 더 적용한 것

- 해시값은 그 자체로 **하나의 데이터**로 간주
  → 해시값을 다시 해시 함수에 입력하면, 또 다른 해시값을 계산할 수 있어야함

<br>

![반복해싱](https://github.com/lbo728/BlockChainStudy/assets/72309817/df812e97-59c2-4d0d-8b78-1912398fdd5b)

<br>

### 3) 결합 해싱

`결합 해싱`(Combined hashing)은 **하나 이상의 데이터에 해싱을 한 번만 적용하여 단일 해시값**을 얻는 방법

- 독립된 데이터들을 합쳐 하나의 데이터로 만들고, 합쳐진 데이터의 해시값을 계산하면 목적 달성
- 주어진 시간 안에 가용한 모든 데이터의 집합에 단일 해시값을 부여할 때 특히 유용
- 주의: 데이터를 합치는 것은 계산 자원, 시간, 기억 공간 등을 소모하므로 결합 해싱은 **개별 데이터가 크지 않을 때만** 사용헤야 함
- 또 다른 단점: 결합된 데이터만 해시 함수에 전달되었기 때문에, **개별 데이터의 해시값은 알 수 없음**

<br>

![결합해싱](https://github.com/lbo728/BlockChainStudy/assets/72309817/a6ecdeda-3b8c-49aa-b0b6-7bf8dd0fd98a)

- 가끔 두 데이터가 합쳐진 곳에 플러스 기호(+) 같은 특수 부호나 해시 태그(#)를 사용하기도 하는데, 이 경우 최종 해시값이 달라짐

### 4) 순차적 해싱

`순차적 해싱`(Sequential hashing)의 목표는 새로운 데이터가 도착할 때마다 해시값을 즉시 갱신하는 것

- 즉, 기존의 해시값이 새로운 데이터와 합쳐져서 해시 함수에 건네져 해시값이 갱신되는 방식
- `결합 해싱`과 `반복 해싱`을 동시에 사용하여 이 목표를 성취 할 수 있음
- 단일 해시값만 유지하면서 새로우 데이터가 도착하는 즉시 해시값을 갱신하고자 할 때 특히 유용
- 장점: 특정 시점의 해시값으로 해당 데이터가 도착한 시점을 추적 가능

<br>

![순차해싱](https://github.com/lbo728/BlockChainStudy/assets/72309817/3780ef33-60dc-43ca-86a3-89c9643f3bd1)

<br>

### 5) 계층적 해싱

결합 해싱과 유사하게 `계층적 해싱`(Hierarchical hashing)의 아이디어도 데이터 묶음에서 단일 해시값을 얻고자 하는 것

- 두 `해시값`에 결합 해싱을 적용하면 최상위에 단일 해시값을 가지는 작은 계층이 형성됨
- 계층적 해싱은 길이가 매번 변하는 입력이 아니라, 늘 일정한 길이의 해시값을 합치므로 상당히 효율적
- 결합 해싱과의 차이: 결합 해싱은 제공된 모든 데이터를 한꺼번에 결합하는 반면, 계층적 해싱은 매 단계에서 오직 **2개의** 해시값만 결합
