# 해시값은 어디서 어떻게 사용될까? (p110 ~ p127)

데이터 비교하고, 계산 퍼즐 만드는 다섯 가지 이야기

## 사례 1 | 데이터 비교

해시값을 사용해 데이터를 비교하는 것은 해시값을 사용하는 가장 간단한 실사례

### 1) 목표

목표는 데이터(파일, 트랜젝션 데이터 등)를 비교하는 것

- 단, 데이터의 크기나 내용과 상관없이 오직 숫자 두 개만 대조해서 쉽게 비교할 수 있도록

### 2) 아이디어

데이터 내용 전체를 비교하는 대신, `암호화된 해시값`을 비교

### 3) 작동 원리

비교하려는 모든 데이터의 암호화 해시값을 계산한 다음 서로 비교

- 암호화된 해시값이 다르면 비교 데이터도 다른 것
- 반대로, 2개 이상의 암호화 해시값이 동일하면 해당 입력 데이터도 동일한 것

### 4) 작동하는 이유

암호화 해시값을 통해 데이터를 비교할 수 있는 암호화 해시 함수의 `충돌 회피` 성질 때문

<br>

## 사례 2 | 데이터의 변경 감지

해시값을 이용한 데이터 비교 아이디어를 조금만 확장하면 데이터 변경을 감지하는데 응용 가능

### 1) 목표

목표는 데이터(파일, 트랜잭션 데이터 등)가 **일정 시간이 경과한 후**, 또는 **타인에게 전송한 뒤**, 또는 **데이터베이스에 저장한 후** 변경되었는지 확인하는 것

### 2) 아이디어

**과거에 기록해 둔 암호화 해시값**과 **검사하려는 데이터에서 새로 생성한 암호화 해시값**을 서로 비교하여 변경되었는지 알아내는 것이 핵심 아이디어

### 3) 작동 원리

데이터 전송 전에 해시값을 생성해 두고, 데이터를 수신한 사람이 새로 해시값을 생성해 두 값을 비교해 보면 전송 도중에 데이터가 변경되었는지 여부를 확인할 수 있음

1. 변경되어서는 안 되는 데이터의 암호화 해시값을 만들어둔다.
2. 추후 데이터가 변경되었는지 확인해야할 때, 데이터의 암호화 해시값을 다시 생성
3. 새로 생성된 해시값과 이전에 만들르어둔 해시값을 서로 비교
   - 누군가에게 데이터를 전송할 때도 동일
4. 두 해시값이 동일하다면 데이터는 기존 해시값이 생성된 이후로 변경된 적이 없다는 뜻

### 4) 작동하는 이유

암호화 해시 함수의 `충돌 회피` 성질로 인해 가능

- 데이터의 변경 감지는 어떤 이벤트(시간의 흐름, 데이터베이스에 저장 또는 추출, 네트워크를 통한 전송 등) 전후의 해시값 비교를 통해 이루어진다.

<br>

## 사례 3 | 변경-감지 방식의 데이터 참조

### 1) 목표

목표는 어딘가(하드디스크, 데이터베이스 등)에 저장된 데이터(트랜잭션 데이터 등)를 참조하여 데이터가 변경되지 않았다는 것을 보장하는 것

### 2) 아이디어

데이터와 그 데이터가 저장된 `장소 정보`를 서로 결합하여 해시값으로 암호화하는 것이 핵심 아이디어

- 데이터에 변경이 있었다면, **데이터와 저장 장소에 대한 정보가 일치하지 않게 되므로** 해시 참조는 유효하지 않게됨

### 3) 작동 원리

해시 참조는, 참조값으로 `암호화 해시값`을 활용한다.

- 해시 참조는 한번 생성된 이후 절대 변경되어서는 안 되는 데이터와 관련된 모든 경우에 활용 가능

  - 해시 참조를 이용하여 참조 데이터가 만들어진 뒤로 데이터가 변경되지 않았는지 검증 가능
  - 참조한 데이터가 변경된 경우, 그 참조값으로는 더 이상 데이터를 추출 할 수 없음
  - 핵심 아이디어: 기술적인 오류 혹은 누군가의 고의로 인해 사용자도 모르게 참조 데이터가 변경되었을 때, 원본 데이터를 추출하지 못하도록 보호하기

> 컴퓨터 프로그램은 데이터가 저장된 장소를 기억했다가 나중에 추출하기 위해 `참조값`을 사용한다.(예시: 외투보관실 티켓)

### 4) 도식 이해하기

블록체인은 `해시 참조`에 크게 의존한다.

다음에 이어질 그림들의 2가지 목적

1. 해시 참조의 기능 도식화
2. 후속 단계에서 `블록체인-데이터-구조`의 기능을 설명할 때 줄곧 사용할 해시 참조 관련 `기호 표기법`을 소개

<br>

#### 유효한 해시 참조 도식

![유효한_해시_참조](https://github.com/lbo728/BlockChainStudy/assets/72309817/7b3d7eb2-1a55-49b8-b51f-3cb40ff42726)

- **회색 원(R1)**: 처음 생성된 해시 참조
- **흰 상자**: 변경되어서는 안되는 데이터
- **화살표**: 해시 참조의 기능
  - 방향: 참조값 → 데이터

<br>

#### 손상된 혹은 유효하지 않은 해시 참조 도식

![유효하지_않은_해시_참조](https://github.com/lbo728/BlockChainStudy/assets/72309817/daa751a8-9f83-49fb-a996-eba67f81076b)

- **회색 원(R1)**: 처음 생성된 해시 참조
- **검은 상자**: 참조가 생성된 이후 변경이 된 데이터
- **지그재그 화살표**: 해시 참조 R1이 깨졌음을 강조하고, 데이터가 변경되었기 때문에 더 이상 데이터의 추출을 허용하지 않는다는 표시

<br>

#### 데이터 변경 후 새로 생성된 해시 참조 도식

![데이터_변경_후_해시](https://github.com/lbo728/BlockChainStudy/assets/72309817/a23ed2d9-ccea-4aeb-ac2b-8f9641eec782)

- **회색 원(R1)**: 새로 생성된 해시 참조
- **검은 상자**: 참조가 생성된 이후 변경이 된 데이터
- **화살표**: 해시 참조의 기능 묘사

<br>

### 5) 작동하는 이유

서로 다른 데이터 조각들이 동일한 해시값을 가지는 일은 거의 일어나지 않음
→ 즉, 해시 참조가 깨진 것은 **해시 참조가 생성된 이후 데이터가 변경되었다는** 증거

- 해시 참조의 핵심은 암호화 해시값을 활용하는 것
- `암호화 해시값`은 데이터의 고유한 지문

<br>

## 사례 4 | 변경-감지 방식으로 데이터 저장

### 1) 목표

목표는 변경되어서는 안되는 방대한 데이터, 즉 트랜잭션 데이터를 저장하는 것

- 동시에, 데이터에 대한 어떠한 변경도 빠르고 손쉽게 변경할 수 있어야 함

### 2) 아이디어

`변경-감지 방식`: 데이터를 저장할 때, 다른 데이터를 가리키는 해시 참조를 함께 저장할 수 있음

- 가리킨 데이터가 또 다른 데이터를 가리키는 해시 참조와 함께 저장하는 방식으로 연속적으로 긴 체인을 형성할 수 있는 것
- 이중 어느 한 데이터라도 해시 참조가 변경이 되어 **전체 해시 참조가 손상되게 만들면**, 해시 참조 생성 이후 데이터가 변경되었다는 증거가 됨

> **비유: 티켓을 다른 외투 주머니에 넣어둔 채 그 외투도 보관실에 맡기면 어떻게 될까?**  
> 나중에 받은 보관실 티켓은 주머니에 보관실 티켓이 들어 있는 외투를 가리키고, 그 주머니에 든 티켓은 또 처음 외투를 가리킨다. 이런 식으로 주머니에 든 티켓이 다른 외투를 가리키고 그 안에 든 티켓이 또 다른 외투를 가리키는 아주 길고도 복잡한 체인을 만들 수 있다.

<br>

### 3) 작동 원리

#### 1 | 체인 방식

데이터의 체인 방식 연결은 `연결 리스트`(linked list)라고도 불리는데, 각 데이터가 다른 데이터의 해시 참조를 가지는 구조로 만들어짐
→ 이런 구조는 데이터가 **순차적으로** 나타날 때 유용

<br>

![체인형식](https://github.com/lbo728/BlockChainStudy/assets/72309817/f5066c5a-62c2-4a56-ab9d-6fe125f42031)

1. `데이터 1`이라는 이름의 데이터와 그 해시 참조 `R1`의 생성에서 시작
   - 데이터 1은 맨 처음 데이터이기 때문에, 해시 참조를 가지고 있지 않음
2. 새로운 데이터가 나타나면 데이터 1을 가리키는 해시 참조 R1과 함께 묶어 해시 참조 `R2`를 만든다.
   - R2는 새로 나타난 데이터 2와 해시 참조 R1을 가리킨다.
3. 비슷한 방식으로 데이터 3과 해시 참조 R2를 가리키는 해시 참조 `R3`가 생성된다.

<br>

#### 2 | 트리 방식

해시 참조와 트랜잭션 데이터가 트리 형태로 연결된 방식으로, `머클 트리`(Merkle tree)라 불림

> **머클 트리**: 이 구조를 처음 제안한 컴퓨터 과학자 머클의 이름과, 나무가 거꾸로 서있는 듯한 형상을 따서 지어진 이름

- 같은 시각에 존재하는 모든 데이터를 한데 묶어 단일 해시 참조로 접근하고자 할 때 아주 유용함

![트리형식](https://github.com/lbo728/BlockChainStudy/assets/72309817/fa3781c7-8725-4306-8f7b-e4c15a64efac)

1. 최하단의 흰 상자로 표시된 4개의 `트랜잭션 데이터`로부터 시작
2. 각 트랜잭션 데이터를 가리키는 해시 참조 4개를 `R1`부터 `R4`까지 생성한 후 둘씩 쌍을 이루게 함
3. 그 뒤, 각 해시 참조 쌍을 가리키는 해시 참조 `R12`와 `R34`를 생성
4. 이 작업을 단일 해시 참조만 남을 때까지 반복
5. 최종적으로 남은 단일 해시 참조를 머클 트리의 `루트`(해시 참조 R)라 부름

<br>

### 4) 작동하는 이유

트리 형태로 연결된 데이터 구조는 데이터와 해시 참조를 연결하여 결합하므로, `변경-감지 방식`으로 데이터를 저장할 수 있음

- 해시 참조는 참조 생성 후, 참조하는 데이터가 변경될 경우 손상됨
- 따라서, 이런 구조에서 손상된 참조를 발견한다면 이는 **구조 생성 후 데이터가 변경되었다는 증거**가 됨

<br>

## 사례 5 | 시간-소모적 계산량 유발

해시값은 컴퓨터끼리 `퍼즐 대결`을 하는 데 사용할 수 있음

### 1) 목표

이 퍼즐의 풀이 방법은 IQ 테스트와 달리, 오로지 엄청난 양의 컴퓨터 계산 자원에 의존하는 것 뿐이어야 함

> **옮긴이주** '비트코인을 캔다'는 의미로 쓰이는 '채굴'은 사실 **블록을 만드는 행위**를 의미한다. 직접 새 블록을 만들기 위해서는 반드시 해시 퍼즐을 풀어야만 한다. 흔히 수학 문제를 풀면 비트코인이 주어진다고 알려진 수학 문제가 바로 해시 퍼즐이다. 실제로는 수학 문제보다는 산수 문제가 더 정확한 표현이다.

<br>

### 2) 아이디어

`해시 퍼즐`은 엄청나게 많은 시행착오를 통해 번호키를 열려고 하는 시도의 디지털 버전이라 생각할 수 있음

- 어떤 지식이나 지적 추론과도 연관이 없다. 단지 엄청난 시간이 필요

### 3) 작동 원리

- 변경되면 안되는 주어진 데이터
- 자유롭게 변경 가능한 데이터(`난스`nonce)
- 적용할 해시 함수
- 결합 해싱의 해시값에 주어진 제약 조건(`난이도`difficulty level)

![해시퍼즐](https://github.com/lbo728/BlockChainStudy/assets/72309817/b514909c-fdbb-44ca-b431-51e200c845d7)

1. 해시 퍼즐은 오직 시행착오로만 해결 가능
2. `난스`를 추측하고 데이터와 결합해 해시 함수를 사용해 해시값을 계산한 후, 주어진 제약조건에 따라 결과 해시값을 평가해야함
3. 해시값이 제약조건을 만족하면 퍼즐은 풀릴 것
4. 그렇지 않다면, 동일한 과정 반복

어떠한 `난스`가 데이터와 결합해 생성한 해시값이 제약조건을 만족했을 때, 그 난스를 **해답**이라고 부름

- 해시 퍼즐을 해결했다고 주장할 때는 그 **특정 난스**를 보여주어야 함

<br>

### 4) 직접 해시 퍼즐 풀기

[🔗 에제 링크](http://www.blockchain-basics.com/HashPuzzle.html)

"Hello Wolrd!와 합쳐졌을 때 **첫 세자리 수가 모두 0**인 해시값을 생성하는 난스를 찾아라"

| 난스    | 해시할 문자열    | 출력         |
| ------- | ---------------- | ------------ |
| 0       | Hello World! 0   | 4EE4B774     |
| 1       | Hello World! 1   | 3345B9A3     |
| 2       | Hello World! 2   | 72040842     |
| 3       | Hello World! 3   | 02307D5F     |
| ⋮       | ⋮                | ⋮            |
| 613     | Hello World! 613 | E861901      |
| **614** | Hello World! 614 | **000**68A3C |
| 615     | Hello World! 615 | 5EB7483F     |

- 난스 614에서 퍼즐 해결
- 615번의 시행착오가 필요했던 셈

<br>

### 5) 해시 퍼즐의 난이도

해시값이 **특정 제약조건**을 만족시키는 것이 해시 퍼즐의 핵심

- 해시 퍼즐에서 제약조건을 흔히 `난이도`라 부름
  - 난이도는 자연수로 표시하고, 난이도의 숫자는 해시값의 맨 앞자리부터 0으로 채워질 자릿수를 의미
  - 난이도 1: 해시값의 맨 앞자리부터 최소 하나 이상의 0으로 채워져 있어야 함
  - 난이도 10: 해시값의 맨 앞자리부터 연속된 10자리 이상이 0이어야 함

<br>

### 6) 작동 원리

해시 퍼즐은 해시 함수가 `일방향 함수`라는 성질에 전적으로 의존해 작동됨

- 따라서 역함수를 적용해서 퍼즐을 해결하는 것은 불가능
- 난이도는 해를 찾기 위한 **평균 시도 횟수**에 직접적으로 영향을 미치고, 결국 해를 찾기까지 필요한 계산 자원과 시간에 영향을 끼치게 됨
- 일단 해답을 찾기만 하면 난스와 합쳐진 데이터가 제약 조건을 만족하는지 검증하는 것은 무척 쉽고 빠르다.
- 블록체인 중 비트코인의 개념에서, 해시 퍼즐은 종종 `작업 증명`(proof of work)으로 불림

<br>

## 그렇다면, 블록체인에서 해싱을 어떻게 쓸까?

- 트랜잭션 데이터를 변경-감지 방식으로 저장
- 트랜잭션 데이터의 디지털 지문으로 사용
- 블록체인-데이터-구조를 바꾸는 데 계산 자원이 많이 소모되게 만듬
