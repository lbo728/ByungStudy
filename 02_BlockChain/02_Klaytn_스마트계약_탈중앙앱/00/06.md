# 블록체인에서 사용되는 암호화 기법

**_강의: [섹션0-블록체인에서 사용되는 암호화 기법](https://www.inflearn.com/course/lecture?courseSlug=klaytn-%EC%8A%A4%EB%A7%88%ED%8A%B8%EA%B3%84%EC%95%BD%EA%B3%BC-%ED%83%88%EC%A4%91%EC%95%99%EC%95%B1&unitId=30498&tab=curriculum)_**

- 블록체인은 암호학적 기법을 토대로 만들어진 기술

  - 비트코인은 네트워크 참여자 모두가 같은 `원장`을 공유함으로써 투명한 거래가 가능
  - 원장은 어느 주소에 BTC가 있는지 기록하지만, **그 주소가 누구에 속하는지는 기록하지 않음**(anonymity)
  - 비트코인은 `공개키암호`를 사용하여 **명시적인 비밀교환과정 없이** BTC의 소유권 증명을 실행
    <br>

  <img width="921" alt="스크린샷 2024-03-18 오후 5 13 59" src="https://github.com/lbo728/BlockChainStudy/assets/72309817/018cab3c-c67c-4aa1-be60-df02c0599c41">

<br>

### 공개키암호화를 사용한 소유권 증명

- 대부분의 블록체인 주소는 `공개키`로부터 도출된 값
  - Bitcoin: Hash160 of public key where Hash160 = RIPEMD160 + SHA256
  - Ethereum: Rightmost 160 bits of Keccak hash of a public key
- Bitcoin의 경우
  - 임의의 주소 X에 10 BTC가 있다고 가정할 때 Alice는 X에서 또다른 임의의 주소 Y로 5 BTC를 전송(i.e.,transfer 5 BTC from X to Y)하는 거래를 성사시키기 위해 X로 변환되는 공개키와 짝을 이루는 비밀키로 해당 거래를 서명할 수 있어야 한다.
- Ethereum의 경우
  - 임의의 주소 X에 위치한 어카운트의 잔고에 10 ETH가 있다고 가정할 때 Alice는 X에서 또다른 임의의 주소 Y에 위치한 어카운트로 5 ETH를 전송(i.e., transfer 5 ETH from the account at X to the account at Y)하는 거래를 성사시키기 위해 X로 변환되는 공개키와 짝을 이루는 비밀키로 해당 거래를 서명할 수 있어야 한다.

<br>

### 구현 방법으로 나눠본 블록체인

#### UTXO (Unspent Transaction Output) 기반 블록체인

- 블록체인에 사용 가능한 토큰(e.g., Bitcoin) - UTXO들과 사용 자격검증밥법을 기록
- 일반적인 자격검증방법은 `UTXO의 정보와 일치하는 공개키`로 검증가능한 `전자서명`을 제출하는 것
- Bitcoin이 대표적인 UTXO 기반 블록체인
- 돈이 그 자체로 암호화되어 있고, 그 돈을 쓸 때 전자 서명을 준다.
  - 돈에 주소를 줌으로써 보안성도 강화하고 병렬화가 가능한 구조

#### 어카운트 기반 블록체인 (Account-based Blockchain)

- 어카운트는 블록체인을 구성하는 주체(entity)를 표현하며 상태를 기록
- 사용자는 어카운트를 사용할 때마다 `어카운트 공개키`로 검증가능한 `전자서명`을 생성
- **상태를 기록할 수 있기 때문에** `스마트 컨트랙트`를 구현하기 용이
- Ethereum, Klaytn이 대표적인 어카운트 기반 블록체인
- 어떤 어카운트를 사용하기 위해 전자 서명을 준다.
  - 어카운트는 한 번에 여러 가지를 못하고, 순서대로 해야 함 → 순서가 바뀌면 결과값이 바뀌기 때문
    - 대신 `상태`가 생김

<br>

### Ethereum 어카운트, 주소, 상태

- Ethereum 어카운트는 Ethereum의 주체(entity)를 표현하고 그 상태를 기록하는데 사용
- 어카운트는 `EOA`(Externally Owned Acount)와 `스마트 컨트랙트`로 구분
- Ethereum 사용자는 EOA를 사용
- 사용자는 임의의 공개키와 비밀키 쌍(Key Pair)을 생성한 뒤 공개키를 어카운트 주소로 변환하여 EOA를 생성
  - 별도의 승인과정이 필요없으며 Ethereum 네트워크와 통신도 필요없음
  - 위 과정으로 인해 어카운트는 **특정 키페어에 종속**
- 사용자의 상태(state)는 어카운트 주소로 찾을 수 있는 **블록체인 저장공간에 기록**
  <br>

  <img width="686" alt="스크린샷 2024-03-18 오후 5 29 04" src="https://github.com/lbo728/BlockChainStudy/assets/72309817/98fc85ae-4940-4fe5-a2c4-4fa9346e7860">

  <br>

  > - 트랜잭션: 블록체인의 저장 구조에서 `저장의 단위`, `정보의 단위`
  > - 역사: 비트코인이 금융 어플리케이션이었고, 비트코인은 결국 어느 주소에서 어느 주소로 돈을 옮기는 수단인데, 은행권에서는 이 돈의 흐틈을 트랜잭션이라고 표현한다. "트랜잭션이 잘들어갔습니다." , "트랜잭션이 체결되었습니다."라는 표현도 전부 금융권의 영향으로 만들어진 것

<br>

### 트랜잭션 (Transaction, TX)

- `블록`은 트랜잭션들을 **일정한 순서로 정렬하여 저장하는** 컨테이너
- 트랜잭션은 `어카운트`의 행동
- 트랜잭션의 **순서는 중요**
  - TX_1 → TX_2와 TX_2 → TX_1는 다름
- 블록체인 참여자들은 블록을 검증할 때 **트랜잭션들이 올바른 순서대로 정렬되었는지를** 확인 후 합의
- 각각의 트랜잭션들은 **어카운트에 연결된 공개키로 검증가능한** `서명`을 포함

<br>

![스크린샷 2024-03-19 오전 11 47 40](https://github.com/lbo728/BlockChainStudy/assets/72309817/b4abe26d-d22a-45f0-b4a5-0d15df141fb2)

<br>

- 이 트랜잭션 구조는 PoW에서 아주 중요함
  > **블록이 번복될 수 있는 경우:** 세계의 양 끝에 있는 A와 B가 동시에 블록으로 컨펌되었다. 각각 위치한 동네에서 인정받은 블록이 되었다고 하자. 이 둘이 중간지점에서 만나는데 수분, 혹은 수 시간이 소요될 수 있다. 그렇다면 누가 다음 블록으로 인정될 것인지 경쟁이 생긴다. 이때, A 블록이 그 다음 이어서 A-1 블록을 B 블록 보다 빨리 만들었다면, B 블록은 번복된다.

![스크린샷 2024-03-19 오전 11 49 37](https://github.com/lbo728/BlockChainStudy/assets/72309817/54d45b3a-e47a-4897-b1a2-f95fe508a2b4)

### Confirmation vs Finality

- `Confirmation 숫자`는 **트랜잭션이 블록에 포함된 이후 생성된** 블록의 숫자

  - 임의의 트랜잭션 T가 포함된 블록의 높이가 100, 현재 블록높이가 105라면 T의 confirmation 숫자는 6

- PoW를 사용하는 블록체인들은 `finality`가 없기 때문에 confirmation 숫자가 중요

- `Finality`란 **블록의 완결성**을 의미

  - `합의를` 통해 생성된 블록이 **번복되지 않을 경우** 완결성이 존재

- PoW 기반 합의는 **확률에 기반하기 때문에 경우에 따라 블록이 사라질 수 있으므로** 완결성이 부재함

  - PoW 블록체인은 수학적으로 복잡한 퍼즐을 풀어 두개의 올바른 블록을 생성한다면, 두 블록 중 하나는 (eventually) 반드시 사라지게 됨

  - 이 때문에 블록이 **확률적 완경설**을 갖기까지 일정 갯수 이상의 블록이 생성되기를 기다려야 함
  - 제한되는 갯수
    - Bitcoin: 6개
    - Ethereum: 7개 -`6번` 정도 지나면 `99.9%` 확률로 나의 트랜잭션이 포함되어 있는 블록은 `Final`이다. → `0.1%`의 문제는 존재하기 때문에, **확률적 Finality**

### Understanding Bitcoin's 6 Confirmations Rule

- 네트워크 시차로 인해 생성된 우연한 복수의 블록들 가운데 하나가 선택되는데 필요한 블록은 두어개 정도 → 2 ~ 3 Confirmations
- 퍼즐을 빠르게 풀 수 있는 악의적인 참여자(공격자)가 있을 경우, 그 참여자의 해시능력(Hash Power)에 따라 필요한 Confirmation 숫자가 달라짐

  - 해시능력이 높을 수록 퍼즐을 푸는 속도도 빠르기 때문에 주어진 문제를 먼저 풀 확률이 높아짐
  - 해시능력이 높은 참여자는 `longest chain`을 임의로 선택 또는 생성할 수 있음
  - 따라서 해시능력을 감안하더라도 임의로 블록체인을 변경하지 못할 정도로 충분히 많은 블록이 생성되기를 기다려야할 필요가 생김
  - Bitcoin의 `6 Confirmation 법칙`은 공격자가 전체 해시능력의 `약 25%`를 가질 때를 가정한 숫자

  <br>

  ![스크린샷 2024-03-19 오후 1 28 23](https://github.com/lbo728/BlockChainStudy/assets/72309817/9686ea4f-59c8-4b0b-8fad-2c58182fee2b)

<br>

### BFT 기반 블록체인

- BFT 기반 블록체인은 블록의 완경설이 보장됨
  - **네트워크가 동기화**되어 있기 때문
  - 블록 생성이 PoW에 비해 **빠르고 경제적**
- 하지만 **네트워크 동기화의 필요로 인해** 참여자의 숫자가 제한됨
  - 네트워크 참여자 구성이 **고정되어 있어야** 합의가 가능
  - 구성이 변경될 경우 **모든 네트워크 참여자가 새로운 구성을 인지하기까지** 합의 불가능
  - 합의 알고리즘이 네트워크 동기화를 가정하고 짜여졌기 떄문에 **네트워크 사용량이 높음**
  - 참여자가 많아질 경우 **네트워크 오버헤드로 인해** 합의가 느림
