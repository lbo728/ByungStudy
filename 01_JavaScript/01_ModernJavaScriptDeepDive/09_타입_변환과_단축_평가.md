# 09장 타입 변환과 단축 평가

# 9.1 타입 변환이란?

#### 개발자가 의도적으로 값의 타입을 변환하는 것

- `명시적 타입 변환`(_explicit coercion_) 또는 `타입 캐스팅`(_type casting_)

<br>

```js
var x = 10;

// 명시적 타입 변환
// 숫자를 문자열로 타입 캐스팅한다.
var str = x.toString();
console.log(typeof str, str); // string 10

// x 변수의 값이 변경된 것은 아니다.
console.log(typeof x, x); // number 10
```

<br>

#### 개발자 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 변환되는 것

- `암묵적 타입 변환`(_implicit coercion_) 또는 `타입 강제 변환`(_type coercion_)

<br>

```js
var x = 10;

// 암묵적 타입 변환
// 문자열 연결 연산자는 숫자 타입 x의 값을 바탕으로 새로운 문자열을 생성한다.

var str = x + '';
console.log(typeof str, str); // string 10

// x 변수의 값이 변경된 것은 아니다.
console.log(typeof x, x); // number 10
```

<br>

#### 타입 변환이 원시 값을 변경하는가

- 명시적 타입 변환이나 암묵적 타입 변환이 기존 `원시 값`(위 예제의 경우 x 변수의 값)을 **직접 변경하는 것은 아님**

  - 원시 값은 `변경 불가능한 값`(_immutable value_)이므로 변경할 수 없음

- 위 예제의 경우 자바스크립트 엔진은 x + ''을 평가하기 위해 x 변수의 숫자 값을 바탕으로 새로운 문자열 값 '10'을 생성하고 이것으로 표현식 '10' + ''를 평가함
  - **이때 암묵적으로 생성된 문자열 '10'은 x 변수에 재할당되지 않음**
- 즉, 암묵적 타입 변환은 기존 변수 값을 재할당하여 변경하는 것이 아님
  - 자바스크립트 엔진은 **표현식을 에러 없이 평가하기 위해** 피연산자의 값을 `암묵적 타입 변환`해 **새로운 타입의 값을 만들어 단 한 번 사용하고 버림**

<br>

#### 의도 파악 측면

- `명시적 타입 변환`: 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러남

- `암묵적 타입 강제 변환`: 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 나타나지 않음
  - 자바스크립트 엔진에 의해 암묵적으로 자동 변환되기 때문

→ 어느 쪽이라도 **타입 변환 결과가 예측 가능해야** 오류를 생산할 가능성을 낮출 수 있음

<br>

#### ❓ 명시적 타입 변환만 사용하고 암묵적 타입 변환은 발생하지 않도록 코드를 작성한다면?

→ 때로는 명시적 타입 변환보다 **암묵적 타입 변환이 가독성 측면에서 더 좋을 수 있음**

- e.g., 자바스크립트 문법을 잘 이해하고 있는 개발자에게는 `(10).toString()`보다 `10+''`이 더욱 간결하고 이해하기 쉬움

- 결국 중요한 것은 **코드를 예측할 수 있어야 한다는 것**

<br>
<br>

# 9.2 암묵적 타입 변환

자바스크립트 엔진은 표현식을 평가할 때 개발자의 의도와는 상관없이 코드의 문맥을 고려해 암묵적으로 데이터 타입을 강제 변환(`암묵적 타입 변환`)할 때가 있음

<br>

```js
// 피연산자가 모두 문자열 타입이어야 하는 문맥
'10' + 2; // -> '102'

// 피연산자가 모두 숫자 타입이어야 하는 문백
5 * '10'; // -> 50

// 피연산자 또는 표현식이 불리언 타입이어야 하는 문백
!0; // -> true
if (1) {
}
```

<br>

- 위 예제와 같이 표현식을 평가할 때 코드의 문맥에 부합하지 않는 다양한 상황이 밣생할 수 있음
  - 이떄 프로그래밍 언어에 따라 에러를 발생시키기도 하지만, **자바스크립트는 가급적 에러를 발생시키지 않도록** `암묵적 타입 변환`을 통해 표현식을 평가함
- 암묵적 타입 변환이 발생하면 `문자열`, `숫자`, `불리언`과 같은 원시 타입 중 하나로 타입을 자동 변환함

<br>
<br>

## 9.2.1 문자열 타입으로 변환

```js
1 + '2'; // -> "12"
```

<br>

- 위 예제의 `+ 연산자`는 피연산자 중 하나 이상이 문자열이므로 `문자열 연결 연산자`로 동작함
  - 문자열 연산자의 역할을 **문자열 값을 만드는 것**
  - 따라서, 문자열 연결 연산자의 모든 피연산자는 **코드의 문맥상** 모두 문자열 타입이어야 함
- **자바스크립 엔진은 문자열 연결 연산자 표현식을 평가하기 위해** 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 `암묵적 타입 변환`함
- 당연하게도 연산자 표현식의 피연산자(피연산자도 표현식)만이 암묵적 타입 변환의 대상이 되는 것은 아님
  - 예를 들어, ES6에서 도입된 `템플릿 리터럴의 표현식 삽입`은 표현식의 평가 결과를 문자열 타입으로 암묵적 타입 변환함

<br>

```js
`1 + 1 = ${1 + 1}`; // "1 + 1 = 2"
```

<br>

자바스크립트 엔진은 문자열 타입 아닌 값을 문자열 타입으로 암묵적 타입 변환을 수행할 때 다음과 같이 동작함

<br>

```js
// 숫자 타입

0 + ''; // -> "0"
0 + ''; // -> "0"
1 + ''; // -> "1"
1 + ''; // -> "-1"
NaN + ''; // -> "NaN"
Infinity + ''; // -> "Infinity"
Infinity + ''; // -> "-Infinity"

// 불리언 타입
true + ''; // -> "true"
false + ''; // -> "false"

// null 타입
null + ''; // -> "null"

// undefined 타입
undefined + ''; // -> "undefined"

// 심벌 타입
(Symbol()) + '' // -> TypeError: Cannot convert a Symbol value to a string

// 객체 타입
({}) + '' // -> "[object Object]"
Math + '' // -> "[object Math]"
[] + '' // -> ""
[10, 20] + '' // -> "10, 20"
(function(){}) + '' // -> "function(){}"
Array + '' // -> "function Array() {[native code]}"
```

<br>
<br>

## 9.2.2 숫자 타입으로 변환

``` js
1 - '1' // -> 0
1 * '10' // -> 10
1  / 'one' // -> NaN
```

위 예제에서 사용한 연산자는 모두 산술 연산자

- 산술 연산자의 역할은 숫자 값을 만드는 것
- 산술 연산자의 모든 피연산자는 코드 문맥상 모두 숫자 타입이어야함
- 따라서 자바스크립트 엔진은 산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자 중에서 **숫자 타입이 아닌 피연산자를 숫자 타입으로 `암묵적 타입변환`함**

<br>

```js
'1' > 0; // -> true
```

<br>

비교 연산자의 역할은 불리언 값을 만드는 것

- `> 비교 연산자`는 피연산자의 크기를 비교하므로 모든 피연산자는 코드의 문맥상 모두 숫자 타입어야 함
- 자바스크립트 엔진은 비교 연산자 표현식을 평가하기 위해 비교 연산자의 피연산자 중에서 **숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 `타입 변환`함**

<br>

자바스크립트 엔진은 숫자 타입이 아닌 값을 숫자 타입으로 암묵적 타입 변환을 수행할 때 다음과 같이 동작함

- 즉, `+ 단항 연산자`는 피연산자가 숫자 타입의 값이 아니면 숫자 타입의 값으로 암묵적 타입 변환을 수행함

<br>

```plain
// 문자열 타입

+'' + // -> 0
+'0'; // -> 0
+'1'; // -> 1
+'string'; // -> NaN

// 불리언 타입
+true  // -> 1
+false  // -> 0

// null 타입
+null  // -> 0

// undefined 타입
+undefined  // -> NaN

// 심벌 타입
+Symbol()  // -> TypeError: Cannot convert a Symbol value to a number

// 객체 타입
+{}  // -> NaN
+[]  // -> 0
+[10, 20] // -> NaN
+(function(){}) // -> NaN
```

<br>
  
- `빈 문자열('')`, `빈 배열([])`, `null`, `false`는 0으로, `true`는 1로 변환됨
- `객체와 빈 배열이 아닌 배열`, `undefined`는 변환되지 않아 NaN이 된다는 것에 주의하자

<br>
<br>

## 9.2.3 불리언 타입으로 변환
